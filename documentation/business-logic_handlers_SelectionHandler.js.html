<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: business-logic/handlers/SelectionHandler.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: business-logic/handlers/SelectionHandler.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import SvgHandler from "./SvgHandler.js";
import Graph from "../../entities/graph/Graph.js";

let _singleton = Symbol();

/**
 * Handles selection state for nodes and edges.
 * Manages single and rectangle selections and keeps SVG UI in sync.
 */
export default class SelectionHandler {
    constructor(singletonToken) {
        if (_singleton !== singletonToken)
            throw new Error("Use SelectionHandler.instance instead of direct instantiation.");

        this._nodes = new Map();
        this._edges = new Map();
        this._affectedEdges = new Map();
        this._rectActive = false;
        this._singleEdge = false;
    }

    // ----------- Singleton Accessor -----------
    static get instance() {
        if (!this[_singleton])
            this[_singleton] = new SelectionHandler(_singleton);
        return this[_singleton];
    }

    // ----------- Getters -----------
    get singleEdge() { return this._singleEdge; }
    get selectedNodes() { return this._nodes.values(); }
    get selectedEdges() { return this._edges.values(); }
    get affectedEdges() { return this._affectedEdges.values(); }

    // ----------- Queries -----------
    isAnySelected() { return this._nodes.size > 0 || this._edges.size > 0; }
    isNodeSelected(node) { return this._nodes.has(node.id); }
    isEdgeSelected(edge) { return this._edges.has(edge.id); }
    isEdgeAffected(edge) { return this._affectedEdges.has(edge.id); }
    isRectActive() { return this._rectActive; }

    // SELECTION LOGIC
    /** Select a single node (clears previous selection). */
    selectNode(node) {
        this.clear();
        const svgh = SvgHandler.instance;

        this._nodes.set(node.id, node);
        svgh.selectNode(node, true);

        // Mark connected edges as affected
        node.adjacent.forEach(edge =>
            this._affectedEdges.set(edge.id, { edge, mod: node })
        );
    }

    /** Select a single edge (and its two nodes). */
    selectEdge(edge) {
        this.clear();
        const svgh = SvgHandler.instance;

        this._edges.set(edge.id, edge);
        svgh.selectEdge(edge, true);

        const addNodeWithAffected = (node, mainEdge) => {
            this._nodes.set(node.id, node);

            const adj = node.adjacent;
            if (adj.length === 2) {
                const affected = adj[0] !== mainEdge ? adj[0] : adj[1];
                if (!this._affectedEdges.has(affected.id)) {
                    this._affectedEdges.set(affected.id, { edge: affected, mod: node });
                }
            }
        };

        addNodeWithAffected(edge.from, edge);
        addNodeWithAffected(edge.to, edge);

        this._singleEdge = true;
    }

    // RECTANGLE SELECTION LOGIC
    startRectSelection(start) {
        this.clear();
        const svgh = SvgHandler.instance;

        this._start = start;
        this._moved = start;
        this._rectActive = true;

        svgh.setRectSelection(start, start);
        svgh.setRectSelectionVisible(true);
    }

    moveRectSelection(moved) {
        this._moved = moved;
        SvgHandler.instance.setRectSelection(this._start, moved);
    }

    endRectSelection() {
        const graph = Graph.instance;
        const svgh = SvgHandler.instance;
        const { _start: start, _moved: moved } = this;

        const xMin = Math.min(start.x, moved.x);
        const xMax = Math.max(start.x, moved.x);
        const yMin = Math.min(start.y, moved.y);
        const yMax = Math.max(start.y, moved.y);

        const isInside = (x, y) => x >= xMin &amp;&amp; x &lt;= xMax &amp;&amp; y >= yMin &amp;&amp; y &lt;= yMax;

        graph.forEachNode(node => {
            const { x, y } = node.pos;
            if (!isInside(x, y)) return;

            this._nodes.set(node.id, node);
            svgh.selectNode(node, true);

            node.adjacent.forEach(edge => {
                const { from, to } = edge;
                const insideEdge =
                    isInside(from.pos.x, from.pos.y) &amp;&amp; isInside(to.pos.x, to.pos.y);

                if (!this._edges.has(edge.id) &amp;&amp; !this._affectedEdges.has(edge.id)) {
                    if (insideEdge) {
                        this._edges.set(edge.id, edge);
                        svgh.selectEdge(edge, true);
                    } else {
                        this._affectedEdges.set(edge.id, { edge, mod: node });
                    }
                }
            });
        });

        svgh.setRectSelectionVisible(false);
        this._rectActive = false;
    }

    cancelRectSelection() {
        SvgHandler.instance.setRectSelectionVisible(false);
        this._rectActive = false;
    }

    // UTILITIES
    /** Clear current selection and update the SVG display. */
    clear() {
        const svgh = SvgHandler.instance;

        // Deselect all nodes
        this._nodes.forEach(node => svgh.selectNode(node, false));
        this._nodes.clear();

        // Deselect all edges
        this._edges.forEach(edge => svgh.selectEdge(edge, false));
        this._edges.clear();

        this._affectedEdges.clear();
        this._singleEdge = false;
    }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="module.html#.exports">exports</a></li><li><a href="module.exports_module.exports.html">exports</a></li></ul><h3>Global</h3><ul><li><a href="global.html#DRAWING_AREA_GRID_RASTER_SPACE">DRAWING_AREA_GRID_RASTER_SPACE</a></li><li><a href="global.html#_transition">_transition</a></li><li><a href="global.html#addEdge">addEdge</a></li><li><a href="global.html#addNode">addNode</a></li><li><a href="global.html#calcPathMeta">calcPathMeta</a></li><li><a href="global.html#calcQ">calcQ</a></li><li><a href="global.html#clear">clear</a></li><li><a href="global.html#copy">copy</a></li><li><a href="global.html#createFace">createFace</a></li><li><a href="global.html#createFacet">createFacet</a></li><li><a href="global.html#createMeshSingleForm">createMeshSingleForm</a></li><li><a href="global.html#edgeSize">edgeSize</a></li><li><a href="global.html#erase">erase</a></li><li><a href="global.html#escape">escape</a></li><li><a href="global.html#exportCC3File">exportCC3File</a></li><li><a href="global.html#fixAndSnapPoint">fixAndSnapPoint</a></li><li><a href="global.html#forEachEdge">forEachEdge</a></li><li><a href="global.html#forEachNode">forEachNode</a></li><li><a href="global.html#fromJSON">fromJSON</a></li><li><a href="global.html#getAdjacentNodes">getAdjacentNodes</a></li><li><a href="global.html#getEdge">getEdge</a></li><li><a href="global.html#getNode">getNode</a></li><li><a href="global.html#hasEdge">hasEdge</a></li><li><a href="global.html#hasNode">hasNode</a></li><li><a href="global.html#importCC3File">importCC3File</a></li><li><a href="global.html#instance">instance</a></li><li><a href="global.html#intersect">intersect</a></li><li><a href="global.html#mirror">mirror</a></li><li><a href="global.html#nodeSize">nodeSize</a></li><li><a href="global.html#pathToPoints">pathToPoints</a></li><li><a href="global.html#registerAdjacentEdge">registerAdjacentEdge</a></li><li><a href="global.html#removeEdge">removeEdge</a></li><li><a href="global.html#removeNode">removeNode</a></li><li><a href="global.html#reset">reset</a></li><li><a href="global.html#sanitizeFileName">sanitizeFileName</a></li><li><a href="global.html#selectEdge">selectEdge</a></li><li><a href="global.html#selectNode">selectNode</a></li><li><a href="global.html#setQEdge">setQEdge</a></li><li><a href="global.html#toJSON">toJSON</a></li><li><a href="global.html#trace">trace</a></li><li><a href="global.html#traceEdge">traceEdge</a></li><li><a href="global.html#traceForm">traceForm</a></li><li><a href="global.html#unregisterAdjacentEdge">unregisterAdjacentEdge</a></li><li><a href="global.html#updateEdge">updateEdge</a></li><li><a href="global.html#updateNode">updateNode</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Sun Nov 23 2025 21:48:56 GMT+0100 (Mitteleurop√§ische Normalzeit)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
