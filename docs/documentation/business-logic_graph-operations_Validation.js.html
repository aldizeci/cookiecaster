<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: business-logic/graph-operations/Validation.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: business-logic/graph-operations/Validation.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import intersections from "../handlers/Intersections.js";

const _eta = 1e-6; //precision
let _visited, _path, _A, _segments;

/**
 *
 * @param {Graph} graph
 * @returns {{forms: Array, segments: Array, intersections: Array}}
 */
export default function validateGraph(graph) {
    const forms = trace(Array.from(graph._nodes.values()));
    return {forms: forms, segments: _segments, intersections: intersections(_segments)}
}

/**
 * Traces all forms
 * @param {Node[]} nodes - list of all nodes in graph
 * @returns {Array}
 */
let trace = (nodes) => {
    _segments = [];
    const forms = [];
    if (nodes.length === 0) return forms;
    _visited = {};
    for (let i in nodes) {
        if (Object.prototype.hasOwnProperty.call(nodes, i)) {
            const node = nodes[i];
            if (!Object.prototype.hasOwnProperty.call(_visited, node.id)) {
                forms.push(traceForm(node));
            }
        }
    }
    return forms;
};

/**
 * Trace all nodes of a form
 * @param {Node} node - start node of form
 * @returns {{path: string, points: Array, closed: boolean, circDir: undefined, meta: {}}}
 */
let traceForm = (node) => {
    _visited[node.id] = true;
    const form = {
        path: "",
        points: [],
        closed: false,
        circDir: undefined,
        meta: {}
    };
    _path = [`M ${node.pos.x} ${node.pos.y}`];
    _A = 0;
    if (node.adjacent.length > 0) {
        //trace components
        let from = node;
        let edge = node.adjacent[0];
        let to = edge.getOtherNode(node);
        traceEdge(from.pos, to.pos, edge.q);
        while (to.adjacent.length === 2 &amp;&amp; to !== node) {
            const n = to;
            _visited[n.id] = true;
            edge = n.adjacent[0].getOtherNode(n) !== from ?
                n.adjacent[0] :
                n.adjacent[1];
            to = edge.getOtherNode(n);
            from = n;
            traceEdge(from.pos, to.pos, edge.q);
        }
        _visited[to.id] = true;
        if (to === node) {
            //closed form
            form.closed = true;
            form.circDir = _A > 0 ? 'cw' : 'ccw';
            form.path = _path.join(' ') + "z";
            const pathMeta = calcPathMeta(form.path);
            form.points = pathMeta.points;
            form.meta = pathMeta.meta;
        } else if (node.adjacent.length === 2) {
            //trace other edges of start node to mark as visited
            from = node;
            edge = node.adjacent[1];
            to = edge.getOtherNode(node);
            while (to.adjacent.length === 2) {
                const n = to;
                _visited[n.id] = true;
                edge = n.adjacent[0].getOtherNode(n) !== from ?
                    n.adjacent[0] :
                    n.adjacent[1];
                to = edge.getOtherNode(n);
                from = n;
            }
            _visited[to.id] = true;
        }
    }
    return form;
};

/**
 * Adds an edge to path as svg element
 * @param {{x: number, y: number}} from - position of from node
 * @param {{x: number, y: number}} to - position of to node
 * @param {{x: number, y: number}} q - position of bézier point
 */
let traceEdge = (from, to, q) => {
    _path.push(`Q ${q.x} ${q.y} ${to.x} ${to.y}`);
    _A += (to.x + from.x) * (to.y - from.y);
};

/**
 * Calculates the bounding box, center, and polyline points of a path.
 * Uses only the browser’s native SVG API — no external libs.
 */
function calcPathMeta(path) {
    const contour = pathToPoints(path);
    if (!contour || contour.length === 0) return;

    const points = [];
    const plen = contour.length;
    let x1 = Number.MAX_VALUE, y1 = Number.MAX_VALUE, x2 = 0, y2 = 0;
    let cx = 0, cy = 0;

    for (let i = 0; i &lt; plen - 1; i++) {
        const [p0x, p0y] = contour[i];
        const [p1x, p1y] = contour[i + 1];

        const dx = Math.abs(p0x - p1x);
        const dy = Math.abs(p0y - p1y);
        if (dx &lt; _eta &amp;&amp; dy &lt; _eta) continue; // skip duplicates

        // bounding box
        x1 = Math.min(x1, p0x);
        x2 = Math.max(x2, p0x);
        y1 = Math.min(y1, p0y);
        y2 = Math.max(y2, p0y);

        // center
        cx += p0x;
        cy += p0y;

        points.push(contour[i]);
        _segments.push([[p0x, p0y], [p1x, p1y]]);
    }

    return {
        points,
        meta: {
            width: x2 - x1,
            height: y2 - y1,
            center: { x: cx / points.length, y: cy / points.length }
        }
    };
}
/**
 * Samples an SVG path string into [x, y] points using native DOM APIs.
 * @param {string} path
 * @returns {number[][]}
 */
function pathToPoints(path) {
    // Create a temporary in-memory &lt;path> element
    const temp = document.createElementNS("http://www.w3.org/2000/svg", "path");
    temp.setAttribute("d", path);

    const total = temp.getTotalLength();
    const points = [];
    const step = 1; // sample every 1px

    for (let i = 0; i &lt;= total; i += step) {
        const { x, y } = temp.getPointAtLength(i);
        points.push([x, y]);
    }
    return points;
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#AbstractMode">AbstractMode</a></li><li><a href="global.html#DRAWING_AREA_GRID_RASTER_SPACE">DRAWING_AREA_GRID_RASTER_SPACE</a></li><li><a href="global.html#ModeDraw">ModeDraw</a></li><li><a href="global.html#ModeMove">ModeMove</a></li><li><a href="global.html#ModeSelect">ModeSelect</a></li><li><a href="global.html#SelectionHandler">SelectionHandler</a></li><li><a href="global.html#_mesh">_mesh</a></li><li><a href="global.html#calcPathMeta">calcPathMeta</a></li><li><a href="global.html#calcQ">calcQ</a></li><li><a href="global.html#createFace">createFace</a></li><li><a href="global.html#createFacet">createFacet</a></li><li><a href="global.html#createMesh">createMesh</a></li><li><a href="global.html#createMeshSingleForm">createMeshSingleForm</a></li><li><a href="global.html#exportCC3File">exportCC3File</a></li><li><a href="global.html#importCC3File">importCC3File</a></li><li><a href="global.html#intersect">intersect</a></li><li><a href="global.html#intersections">intersections</a></li><li><a href="global.html#pathToPoints">pathToPoints</a></li><li><a href="global.html#round5">round5</a></li><li><a href="global.html#sanitizeFileName">sanitizeFileName</a></li><li><a href="global.html#trace">trace</a></li><li><a href="global.html#traceEdge">traceEdge</a></li><li><a href="global.html#traceForm">traceForm</a></li><li><a href="global.html#validateGraph">validateGraph</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Mon Nov 24 2025 20:43:39 GMT+0100 (Mitteleuropäische Normalzeit)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
